//Press 1, 2, 3, 4, 5 to see different IK skeletal structures
int mode = 1;
int sizeX = 640;
int sizeY = 480;
int startX = sizeX/2;
int startY = sizeY/2;
color BLACK = color(0, 0, 0);
color DK_GRAY = color(100, 100, 100);
color RED = color(200, 80, 80);
color BLUE = color(80, 80, 200);

ArrayList<Bone> boneList = new ArrayList<Bone>();
ArrayList<Bone> boneList2 = new ArrayList<Bone>();
ArrayList<Bone> boneList3 = new ArrayList<Bone>();
ArrayList<Bone> boneList4 = new ArrayList<Bone>();
  
void setup() {
  size(sizeX,sizeY); 
  
  //boneList
  Bone firstBone = new Bone(null, 100, 30, new PVector(startX, startY));
  Bone secondBone = new Bone(firstBone, 80, 30, null);
  Bone thirdBone = new Bone(secondBone, 60, 30, null);
  Bone fourthBone = new Bone(thirdBone, 40, 30, null);
   
  boneList.add(firstBone);
  boneList.add(secondBone);
  boneList.add(thirdBone);
  boneList.add(fourthBone);
  
  //boneList2
  Bone firstBone2 = new Bone(null, 50, 60, new PVector(startX, startY));
  Bone secondBone2 = new Bone(firstBone2, 70, -20, null);
  Bone thirdBone2 = new Bone(secondBone2, 30, 40, null);
  Bone fourthBone2 = new Bone(thirdBone2, 100, -70, null);
   
  boneList2.add(firstBone2);
  boneList2.add(secondBone2);
  boneList2.add(thirdBone2);
  boneList2.add(fourthBone2);
    
  //boneList3
  Bone firstBone3 = new Bone(null, 40, 60, new PVector(80, 80));
  Bone secondBone3 = new Bone(firstBone3, 40, 60, null);
  Bone thirdBone3 = new Bone(secondBone3, 40, 60, null);
  Bone fourthBone3 = new Bone(thirdBone3, 40, 60, null);
  Bone fifthBone3 = new Bone(fourthBone3, 40, 60, null);
  Bone sixthBone3 = new Bone(fifthBone3, 40, 60, null);
  Bone seventhBone3 = new Bone(sixthBone3, 40, 60, null);
   
  boneList3.add(firstBone3);
  boneList3.add(secondBone3);
  boneList3.add(thirdBone3);
  boneList3.add(fourthBone3);
  boneList3.add(fifthBone3);
  boneList3.add(sixthBone3);
  boneList3.add(seventhBone3);
  
  //boneList4
  Bone firstBone4 = new Bone(null, 60, 10, new PVector(sizeX - 80, sizeY - 80));
  Bone secondBone4 = new Bone(firstBone4, 60, 10, null);
  Bone thirdBone4 = new Bone(secondBone4, 300, 10, null);
   
  boneList4.add(firstBone4);
  boneList4.add(secondBone4);
  boneList4.add(thirdBone4);

}

void draw() {
  background(200);
  strokeWeight(2);

  //perform the CDC algorithm
  CDC(boneList);
  CDC(boneList2);
  CDC(boneList3);
  CDC(boneList4);
  
  if (mode == 1 || mode == 5) {
    stroke(BLACK);
    for(Bone bone: boneList) {
      bone.drawMe(); 
    }
  }
  if (mode == 2 || mode == 5) {
    stroke(DK_GRAY);
    for(Bone bone: boneList2) {
      bone.drawMe(); 
    }
  }
  if (mode == 3 || mode == 5) {
    stroke(RED);
    for(Bone bone: boneList3) {
      bone.drawMe(); 
    }
  }
  if (mode == 4 || mode == 5) {
    stroke(BLUE);
    for(Bone bone: boneList4) {
      bone.drawMe(); 
    }
  }
  
}

void CDC(ArrayList<Bone> list) {
  //calculate the IK using Cyclic Coordinate Descent
  PVector target = new PVector(mouseX, mouseY);
  Bone endBone = list.get(list.size() - 1);
  endBone.alignToTarget(target, endBone); //this will recursively rotate the bones one iteration closer to the target
}


class Bone {
   Bone prev; //the parent bone
   int boneLength; //how long the bone is
   float relativeRot; //the rotation in degrees
   PVector relativePos; //offset (use only for the first bone)
   
   Bone (Bone prev, int boneLength, float relativeRot, PVector relativePos) {
     this.prev = prev;
     this.boneLength = boneLength;
     this.relativeRot = radians(relativeRot);
     this.relativePos = relativePos;
   } 
   
   void drawMe () {
     line (getStartPos().x, getStartPos().y, getEndPos().x, getEndPos().y);
   }
   
   //recursive method. call from the last bone
   void alignToTarget(PVector target, Bone endBone) {
       PVector currentBoneVector = new PVector(endBone.getEndPos().x - getStartPos().x, endBone.getEndPos().y - getStartPos().y);
       PVector targetVector = new PVector(target.x - getStartPos().x, target.y - getStartPos().y);
       float angleDiff = PVector.angleBetween(currentBoneVector, targetVector);
       targetVector.sub(currentBoneVector);
  
       //find out which side the target was on in relation to the currentBoneVector
       float position = (0 - currentBoneVector.x) * (targetVector.y - currentBoneVector.y) - (0 - currentBoneVector.y) * (targetVector.x - currentBoneVector.x);

       if (position > 0) { //the target is on the right side of currentBoneVector. reverse the sign
          angleDiff *= -1; 
       }
       relativeRot += angleDiff;
       
       //call the parent bone's method
       if (prev != null) {
         prev.alignToTarget(target, endBone);
       }
       
   }
   
   int getLength () {
     return boneLength; 
   }
   
   float getRot () {
     if (prev == null) {
       return relativeRot; 
     }
     else {
       return prev.getRot() + relativeRot;
     }
   }
   
   PVector getStartPos () {
     if (prev == null) {
       return new PVector(relativePos.x, relativePos.y);
     }
     else {
       return new PVector(prev.getEndPos().x, prev.getEndPos().y);
     }
   }
   
   PVector getEndPos () {
     float endX = getStartPos().x + boneLength * cos(getRot());
     float endY = getStartPos().y + boneLength * sin(getRot());
     return new PVector(endX, endY);
   }
   
}

void keyPressed() {
  if (key == '1'){
    mode = 1;
  }
  else if (key == '2'){
    mode = 2;
  }
  else if (key == '3'){
    mode = 3;
  }
  else if (key == '4'){
    mode = 4;
  }
  else if (key == '5'){
    mode = 5;
  }
  
}